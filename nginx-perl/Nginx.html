<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Nginx</title>
	<meta name="description" content="Pod documentation for Nginx" />
	<meta name="inputfile" content="&lt;standard input&gt;" />
	<meta name="outputfile" content="&lt;standard output&gt;" />
	<meta name="created" content="Thu Dec 22 03:58:42 2011" />
	<meta name="generator" content="Pod::Xhtml 1.61" />
</head>
<style type="text/css"><!--

body { color: #000000; background: #ffffff; min-width: 750px; }

body,div { margin: 0; padding: 0;}

/* layout */

div.row { width: 100%; clear: both; margin: 0; padding: 0; }

div.w100 { width: 40em; }
div.w80 { width: 35em; }

div.centr { margin: 0 auto; }

div.pagepadtop { padding-top: 80px; }
div.pagepadbottom { padding-bottom: 80px; }
div.blockpadtop { padding-top: 10px; }
div.blockpadbottom { padding-bottom: 20px; }

div.cl { clear: both; }
div.fl { float: left; }
div.fr { float: right; }
div.ab { position: absolute; }
div.rl { position: relative; }

div.ph { height: 1px; line-height: 1px; overflow: hidden; } /* placeholder */


/* special, shifting logo a bit left */

div.hlogo { height: 42px; }
div.m2 { margin-left: -2px; }
div.hlogos { height: 29px; }
div.m1 { margin-left: -1px; }

/* links, nv class to avoid highlighting visited links */

a.nv:visited { color: #007a03; }
a.nv:focus, a.nv:hover { color: #f54b00; }
a { color: #007a03; }
a:visited { color: #990099; }
a:focus, a:hover { color: #f54b00; }



/* text */

h1 { font-size: 196%;   font-weight: normal; font-style: normal; }
h2 { font-size: 167%;   font-weight: normal; font-style: normal; }
h3 { font-size: 146.5%; font-weight: normal; font-style: normal; }
h4 { font-size: 123.1%; font-weight: normal; font-style: normal; }
h5 { font-size: 108%;   font-weight: bold;   font-style: normal; }
h6 { font-size: 108%;   font-weight: normal; font-style: italic; }

h1,h2,h3,h4,h5,h6,p,div,ul,li,a,span,b,strong,i { font-family: "Times New Roman", Times; }
a,span,b,strong,i { margin: 0; padding: 0; }
h1,h2,h3,h4,h5,h6,p { padding: 0.5em 0 0.5em 0; }
p { line-height: 1.3em } 
p { margin: 0 0 -0em 0; }
h1,h2 { margin: 0.4em 0 -0.4em 0;  }
h3,h4,h5,h6 { margin: 0.6em 0 -0.6em 0;  }

ul.nls { list-style: none; }

div.pod div { padding: 0 1.7em; }
div.pod ul { list-style: none; }


--></style>

<body>

<div class="row">

	<div class="w100 centr cl pagepadtop blockpadbottom rl hlogos">
		<div class="ab m2 hlogos">
			<a href="index.html" title="nginx-perl"><img 
				src="nginx-perl.gif" border="0"
				alt="nginx-perl" /></a>
		</div>
	</div>

	<div class="w100 centr cl blockpadbottom">

		<h3>Documentation</h3>

		<p><b>Nginx</b> &nbsp;&nbsp; <a href="Nginx/Test.html">Nginx::Test</a> &nbsp;&nbsp; <a href="Nginx/Util.html">Nginx::Util</a> &nbsp;&nbsp; <a href="Nginx/Redis.html">Nginx::Redis</a> &nbsp;&nbsp; <a href="Redis/Parser/XS.html">Redis::Parser::XS</a> &nbsp;&nbsp; <a href="Nginx/Perl.html">Nginx::Perl</a> &nbsp;&nbsp; </p>
	</div>

	<div class="w100 centr cl blockpadtop blockpadbottom">




<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Nginx</h3>

<ul><li><a href="#NAME">NAME</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#RATIONALE">RATIONALE</a></li>
<li><a href="#INSTALLATION">INSTALLATION</a></li>
<li><a href="#RUNNING_EXAMPLES">RUNNING EXAMPLES</a></li>
<li><a href="#BENCHMARKING">BENCHMARKING</a></li>
<li><a href="#CONFIGURATION_DIRECTIVES">CONFIGURATION DIRECTIVES</a></li>
<li><a href="#NAMING">NAMING</a></li>
<li><a href="#HTTP_REQUEST_OBJECT">HTTP REQUEST OBJECT</a></li>
<li><a href="#HTTP_CONTENT_HANDLER">HTTP CONTENT HANDLER</a></li>
<li><a href="#HTTP_ACCESS_HANDLER">HTTP ACCESS HANDLER</a></li>
<li><a href="#FLOW_CONTROL">FLOW CONTROL</a></li>
<li><a href="#ERROR_HANDLING">ERROR HANDLING</a></li>
<li><a href="#ASYNCHRONOUS_API">ASYNCHRONOUS API</a></li>
<li><a href="#CONNECTION_TAKEOVER">CONNECTION TAKEOVER</a></li>
<li><a href="#TIPS_AND_TRICKS">TIPS AND TRICKS</a>
<ul><li><a href="#SELF_SUFFICIENT_HANDLERS">SELF-SUFFICIENT HANDLERS</a></li>
</ul>
</li>
<li><a href="#SEE_ALSO">SEE ALSO</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><hr />
<!-- INDEX END -->

<h1 id="NAME">NAME</h1>
<div id="NAME_CONTENT">
<p>Nginx - full-featured perl support for nginx</p>

</div>
<h1 id="SYNOPSIS">SYNOPSIS</h1>
<div id="SYNOPSIS_CONTENT">
<pre>    use Nginx;

    # nginx's asynchronous resolver
    #     &quot;resolver 1.2.3.4;&quot; in nginx-perl.conf

    ngx_resolver &quot;www.google.com&quot;, 15, sub {
        my (@IPs) = @_;

        if ($!) {
            my ($errcode, $errstr) = @_;
            ngx_log_error $!, &quot;Cannot resolve google's IP: $errstr&quot;;
        }
    };

    # timer

    ngx_timer 5, 0, sub {
        ngx_log_notice 0, &quot;5 seconds gone&quot;;
    };

    # asynchronous connections
    # with explicit flow control

    ngx_connector &quot;1.2.3.4&quot;, 80, 15, sub {
        if ($!) {
            ngx_log_error $!, &quot;Connect error: $!&quot;;
            return NGX_CLOSE;
        }

        my $c = shift;  # connection
        my $wbuf = &quot;GET /\x0d\x0a&quot;;
        my $rbuf;

        ngx_writer $c, $wbuf, 15, sub {
            if ($!) {
                ngx_log_error $!, &quot;Write error: $!&quot;;
                return NGX_CLOSE;
            }

            return NGX_READ;
        };

        ngx_reader $c, $rbuf, 0, 0, 15, sub {
            if ($! &amp;&amp; $! != NGX_EOF) { 
                ngx_log_error $!, &quot;Read error: $!&quot;;
                return NGX_CLOSE;
            }

            if ($! == NGX_EOF) {
                ngx_log_info 0, &quot;response length: &quot; . length ($rbuf);
                return NGX_CLOSE;
            }

            return NGX_READ;  # no errors - read again
        };

        return NGX_WRITE;  # what to do on connect
    };

    # SSL handshake

    ngx_connector &quot;1.2.3.4&quot;, 80, 15, sub {
        ...
        my $c = shift;

        ngx_ssl_handshaker $c, 15, sub {
            ...
            ngx_writer $c, $wbuf, 15, sub {
                ...
            };

            ngx_reader $c, $rbuf, 0, 0, 15, sub {
                ...
            };

            return NGX_WRITE;
        };

        return NGX_SSL_HANDSHAKER;
    };

    # asynchronous response
    # via HTTP API

    sub handler {
        my ($r) = shift;

        $r-&gt;main_count_inc;

        ngx_resolver &quot;www.google.com&quot;, 15, sub {

            $r-&gt;send_http_header ('text/html');

            unless ($!) {
                lcoal $, = ', ';
                $r-&gt;print (&quot;OK, @_\n&quot;);
            } else {
                $r-&gt;print (&quot;FAILED, $_[1]\n&quot;);
            }

            $r-&gt;send_special (NGX_HTTP_LAST);
            $r-&gt;finalize_request (NGX_OK);
        };

        return NGX_DONE;
    }

    # and more... 

</pre>
<p><cite>nginx-perl.conf</cite>:</p>
<pre>    http {

        perl_inc      /path/to/lib;
        perl_inc      /path/to/apps;
        perl_require  My/App.pm;

        perl_init_worker  My::App::init_worker;
        perl_exit_worker  My::App::exit_worker;

        perl_eval  '$My::App::SOME_VAR = &quot;foo&quot;';
        ...

        server {
            location / {
                perl_handler  My::App::handler;
        ...

</pre>
<p><cite>My/App.pm</cite>:</p>
<pre>    package My::App;

    use Nginx;

    sub handler {
        my $r = shift;
        ...
    }
    ...

</pre>

</div>
<h1 id="DESCRIPTION">DESCRIPTION</h1>
<div id="DESCRIPTION_CONTENT">
<p>Nginx with capital <i>N</i> is a part of <strong>nginx-perl</strong> distribution.</p>
<p>Nginx-perl brings asynchronous functions and other useful features 
into embedded perl to turn it into nice and powerful perl web server.</p>

</div>
<h1 id="RATIONALE">RATIONALE</h1>
<div id="RATIONALE_CONTENT">
<p>Nginx is very popular and stable asynchronous web-server.
And reusing as much of its internals as possible gives this project 
same level of stability nginx has. Maybe not right from the beginning,
but it can catch up with a very little effort.</p>
<p>Internal HTTP parser, dispatcher (locations) and different types
of handlers free perl modules from reinventing all that, like most 
of the perl frameworks do. It's already there, native and extremely
fast. </p>
<p>All of the output filters there as well and everything you do
can be gzipped, processed with xslt or through any filter module
for nginx. Again, extremely fast.</p>
<p>Nginx has a pretty decent master-worker model, which allows to do
process management right out of the box.</p>
<p>And probably some other things I can't remember at the moment.</p>
<p>So, why use any of those perl frameworks if we already have 
nginx with nice native implementation for almost everything
they offer. It just needed a little touch.</p>
<p>Additionally I wanted to implement new asynchronous API
with proper flow control and explicit parameters to avoid
complexity as much as possible. </p>

</div>
<h1 id="INSTALLATION">INSTALLATION</h1>
<div id="INSTALLATION_CONTENT">
<p>As usual for perl extensions:</p>
<pre>    % perl Makefile.PL
    % make
    % make test
    % make install

</pre>
<p><cite>Makefile.PL</cite> supports everything <cite>./configure</cite> does. 
To build it with SSL support use something like:</p>
<pre>    % perl Makefile.PL --with-http_ssl_module

</pre>
<p>Or if you want to install it into different perl simply run <cite>Makefile.PL</cite>
undef it:</p>
<pre>    % /home/zzz/perl5/perlbrew/perls/perl-5.14.2/bin/perl Makefile.PL

</pre>
<p>It is safe to install nginx-perl alongside nginx. It uses 
capital <strong>N</strong> for perl modules and <cite>nginx-perl</cite> for binaries.</p>

</div>
<h1 id="RUNNING_EXAMPLES">RUNNING EXAMPLES</h1>
<div id="RUNNING_EXAMPLES_CONTENT">
<p>You don't have to install nginx-perl to try it. There are couple
of ready to try examples in <cite>eg/</cite>:</p>
<pre>    % ./objs/nginx-perl -p eg/helloworld

</pre>
<p>Now open another terminal or your web browser and go to
http://127.0.0.1:55555/ or whatever IP you're on.</p>

</div>
<h1 id="BENCHMARKING">BENCHMARKING</h1>
<div id="BENCHMARKING_CONTENT">
<p>The easiest way to benchmark nginx-perl against node.js is to run
redis example from <cite>eg/redis</cite>, <cite>eg/redis.js</cite> and compare the results. 
But first you need to install <a href="Redis/Parser/XS.html">Redis::Parser::XS</a> from cpan:</p>
<pre>    % cpan Redis::Parser::XS
    ...
    % ./objs/nginx-perl -p eg/redis
    ...

    % ab -c10 -n10000 http://127.0.0.1:55555/
    % ab -c10 -n10000 http://127.0.0.1:55555/single
    % ab -c10 -n10000 http://127.0.0.1:55555/multi

</pre>
<p>Same goes for node.js:</p>
<pre>    % npm install redis
    % npm install hiredis
    ...
    % node eg/redis.js
    ...

    % ab -c10 -n10000 http://127.0.0.1:55555/
    % ab -c10 -n10000 http://127.0.0.1:55555/single
    % ab -c10 -n10000 http://127.0.0.1:55555/multi

</pre>

</div>
<h1 id="CONFIGURATION_DIRECTIVES">CONFIGURATION DIRECTIVES</h1>
<div id="CONFIGURATION_DIRECTIVES_CONTENT">
<dl>
	<dt>perl_inc  /path/to/lib;</dt>
	<dd>
		<p>Works just like Perl's <code>use lib '/path/to/lib'</code>. Supports only one
argument, but you can specify it multiple times.</p>
<pre>    http {
        perl_inc  /path/to/lib;
        perl_inc  /path/to/myproject/lib;




</pre>
	</dd>
	<dt>perl_require  My/App.pm;</dt>
	<dd>
		<p>Same as Perl's own <code>require</code>.</p>
<pre>    http {
        perl_inc      /path/to/lib;
        perl_require  My/App.pm;

</pre>
	</dd>
	<dt>perl_init_worker  My::App::init_worker;</dt>
	<dd>
		<p>Adds a handler to call on worker's start.</p>
<pre>    http {
        perl_inc          /path/to/lib;
        perl_require      My/App.pm;

        perl_init_worker  My::App::init_worker;
        perl_init_worker  My::AnotherApp::init_worker;

</pre>
	</dd>
	<dt>perl_exit_worker  My::App::exit_worker;</dt>
	<dd>
		<p>Adds a handler to call on worker's exit.</p>
<pre>    http {
        perl_inc          /path/to/lib;
        perl_require      My/App.pm;

        perl_exit_worker  My::App::exit_worker;
        perl_exit_worker  My::AnotherApp::exit_worker;

</pre>
	</dd>
	<dt>perl_handler  My::App::handler; </dt>
	<dd>
		<p>Sets current location's http content handler (a.k.a. http handler).</p>
<pre>    http {
        server {
            location / {
                perl_handler My::App::Handler;




</pre>
	</dd>
	<dt>perl_access  My::App::access_handler; </dt>
	<dd>
		<p>Adds an http access handler to the access phase of current location.</p>
<pre>    http {
        server {
            location / {
                perl_access My::App::access_handler; 
                perl_handler My::App::Handler;

</pre>
	</dd>
	<dt>perl_eval  '$My::App::CONF{foo} = &quot;bar&quot;';</dt>
	<dd>
		<p>Evaluates some perl code on configuration level. Useful if you 
need to configure some perl modules directly fron <cite>nginx-perl.conf</cite>.</p>
<pre>    http {
        perl_eval  '$My::App::CONF{foo} = &quot;bar&quot;';

</pre>
	</dd>
	<dt>perl_app  /path/to/app.pl;</dt>
	<dd>
		<p>Sets http content handler to the <code>sub { }</code> returned from
the app. Internally does simple <code>$handler = do '/path/to/app.pl'</code>,
so you can put your app into @INC somewhere to get shorter path.
Additionally prereads entire request body before calling the handler.
Which means there is no need to call $r-&gt;has_request_body there.</p>
<pre>    http {
        server {
            location / {
                perl_app  /path/to/app.pl;

</pre>
	</dd>
</dl>

</div>
<h1 id="NAMING">NAMING</h1>
<div id="NAMING_CONTENT">
<pre>    NGX_FOO_BAR  -- constants
    ngx_*r       -- asynchronous functions (creators)
    NGX_VERB     -- flow control constants 
    ngx_verb     -- flow control functions
    $r-&gt;foo_bar  -- request object's methods

</pre>
<p>Each asynchronous function has an <strong>r</strong> at the end of its name. This is 
because those functions are creators of handlers with some parameters. 
E.g. ngx_writer creates write handler for some connection with some
scalar as a buffer.</p>

</div>
<h1 id="HTTP_REQUEST_OBJECT">HTTP REQUEST OBJECT</h1>
<div id="HTTP_REQUEST_OBJECT_CONTENT">
<p>All the things from official embedded perl are there and almost
completely untouched. There are quite a few new methods though:</p>
<dl>
	<dt>$ctx = $r-&gt;ctx($ctx)</dt>
	<dd>
		<p>Sets and gets some context scalar. It will be useful to get some data 
from access handler for example.</p>
	</dd>
	<dt>$r-&gt;location_name</dt>
	<dd>
		<p>Returns the name of the location.</p>
	</dd>
	<dt>$r-&gt;root</dt>
	<dd>
		<p>Returns the root path.</p>
	</dd>
	<dt>$r-&gt;main_count_inc()</dt>
	<dd>
		<p>Increases value of the internal <code>r-&gt;main-&gt;count</code> by 1 and
therefore allows to send response later from some other callback.</p>
	</dd>
	<dt>$r-&gt;send_special($rc)</dt>
	<dd>
		<p>Sends response. </p>
	</dd>
	<dt>$r-&gt;finalize_request($rc)</dt>
	<dd>
		<p>Decreases <code>r-&gt;main-&gt;count</code> and finalizes request.</p>
	</dd>
	<dt>$r-&gt;phase_handler_inc()</dt>
	<dd>
		<p>Allows to move to the next phase handler from access handler.</p>
	</dd>
	<dt>$r-&gt;core_run_phases()</dt>
	<dd>
		<p>Allows to break out of access handler and continue later from
some other callback.</p>
	</dd>
</dl>

</div>
<h1 id="HTTP_CONTENT_HANDLER">HTTP CONTENT HANDLER</h1>
<div id="HTTP_CONTENT_HANDLER_CONTENT">
<p>This is where response should get generated and send to the client.
Here's how to send response completely asynchronously:</p>
<pre>    sub handler {
        my $r = shift;

        $r-&gt;main_count_inc;

        ngx_timer 1, 0, sub {
            $r-&gt;send_http_header('text/html');
            $r-&gt;print(&quot;OK\n&quot;);

            $r-&gt;send_special(NGX_HTTP_LAST);
            $r-&gt;finalize_request(NGX_OK);
        };

        return NGX_DONE;
    }

</pre>
<p>Notice <code>return NGX_DONE</code> instead of <code>return OK</code>, this is important,
because it allows to avoid post processing response the old way.</p>

</div>
<h1 id="HTTP_ACCESS_HANDLER">HTTP ACCESS HANDLER</h1>
<div id="HTTP_ACCESS_HANDLER_CONTENT">
<p>todo</p>

</div>
<h1 id="FLOW_CONTROL">FLOW CONTROL</h1>
<div id="FLOW_CONTROL_CONTENT">
<p>To specify what to do after each callback we can either call some 
function or return some value and let handler do it for us. 
Most of the ngx_* handlers support return value and even optimized
for that kind of behavior.</p>
<p>Functions take connection as an argument:</p>
<pre>    ngx_read($c)
    ngx_write($c)
    ngx_ssl_handshake($c)
    ngx_close($c)

</pre>
<p>Return values only work on current connection:</p>
<pre>    return NGX_READ;
    return NGX_WRITE;
    return NGX_SSL_HANDSHAKE;
    return NGX_CLOSE;

</pre>
<p>As an example, let's connect and close connection. We will do flow control 
via single <code>return</code> for this:</p>
<pre>    ngx_connector '1.2.3.4', 80, 15, sub {

        return NGX_CLOSE;
    };

</pre>
<p>Now, if we want to connect and then read exactly 10 bytes we need
to create reader and <code>return NGX_READ</code> from connector's callback:</p>
<pre>    ngx_connector '1.2.3.4', 80, 15, sub {

        my $c = shift;

        ngx_reader $c, $buf, 10, 10, 15, sub {
            ... 
        };

        return NGX_READ;
    };

</pre>
<p>This will be different, if we already have connection somehow:</p>
<pre>    ngx_reader $c, $buf, 10, 10, 15, sub {
        ... 
    };

    ngx_read($c);




</pre>

</div>
<h1 id="ERROR_HANDLING">ERROR HANDLING</h1>
<div id="ERROR_HANDLING_CONTENT">
<p>Each ngx_* handler will call back on any error with <code>$!</code> set to some value
and reset to 0 otherwise. 
For simplicity EOF considered to be an error as well and <code>$!</code> will be set
to NGX_EOF in such case. </p>
<p>Example:</p>
<pre>    ngx_reader $c, $buf, 0, 0, sub {

        return NGX_WRITE
            if $! == NGX_EOF;

        return NGX_CLOSE
            if $!;
        ...
    };

</pre>

</div>
<h1 id="ASYNCHRONOUS_API">ASYNCHRONOUS API</h1>
<div id="ASYNCHRONOUS_API_CONTENT">
<dl>
	<dt>ngx_timer $after, $repeat, sub { };</dt>
	<dd>
		<p>Creates new timer and calls back after <code>$after</code> seconds.
If <code>$repeat</code> is set reschedules the timer to call back again after 
<code>$repeat</code> seconds or destroys it otherwise.</p>
		<p>Internally <code>$repeat</code> is stored as a refence, so changing it will influence
rescheduling behaviour.</p>
		<p>Simple example calls back just once after 1 second:</p>
<pre>    ngx_timer 1, 0, sub {
        warn &quot;tada\n&quot;;
    };

</pre>
		<p>This one is a bit trickier, calls back after 5, 4, 3, 2, 1 seconds 
and destroys itself:</p>
<pre>    my $repeat = 5;

    ngx_timer $repeat, $repeat, sub {
        $repeat--;
    };




</pre>
	</dd>
	<dt>ngx_connector $ip, $port, $timeout, sub { };</dt>
	<dd>
		<p>Creates connect handler and attempts to connect to <code>$ip:$port</code> within 
<code>$timeout</code> seconds. Calls back with connection in <code>@_</code> afterwards. 
On error calls back with <code>$!</code> set to some value.</p>
		<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
		<p>Example:</p>
<pre>    ngx_connector $ip, 80, 15, sub {

        return NGX_CLOSE
            if $!;

        my $c = shift;
        ...

        return NGX_READ;
    };

</pre>
	</dd>
	<dt>ngx_reader $connection, $buf, $min, $max, $timeout, sub { };</dt>
	<dd>
		<p>Creates read handler for <code>$connection</code> with buffer <code>$buf</code>.
<code>$min</code> indicates how much data should be present in <code>$buf</code> 
before the callback and <code>$max</code> limits total length of <code>$buf</code>.</p>
		<p>Internally <code>$buf</code>, <code>$min</code>, <code>$max</code> and <code>$timeout</code> are stored
as refernces, so you can change them at any time to influence
reader's behavior.</p>
		<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
		<p>On error calls back with <code>$!</code> set to some value, including 
NGX_EOF in case of EOF. </p>
<pre>    my $buf;

    ngx_reader $c, $buf, $min, $max, $timeout, sub {

        return NGX_CLOSE
            if $! &amp;&amp; $! != NGX_EOF;
        ...

        return NGX_WRITE;
    };

</pre>
		<p>Be aware, that <code>$min</code> and <code>$max</code> doesn't apply to the amount of data
you want to read but rather to the appropriate buffer size to call back with.</p>
	</dd>
	<dt>ngx_writer $connection, $buf, $timeout, sub { };</dt>
	<dd>
		<p>Creates write handler for <code>$connection</code> with buffer <code>$buf</code> and 
write timeout in &lt;$timeout&gt;.</p>
		<p>Internally <code>$buf</code> and <code>$timeout</code> are stored as references, so 
changing them will influence writer's behavior. </p>
		<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
		<p>On error calls back with <code>$!</code> set to some value. NGX_EOF should be
treated as fatal error here. </p>
		<p>Example:</p>
<pre>    my $buf = &quot;GET /\n&quot;;

    ngx_writer $c, $buf, 15, sub {

        return NGX_CLOSE
            if $!;
        ...

        return NGX_READ;
    };

</pre>
	</dd>
	<dt>ngx_ssl_handshaker $connection, $timeout, sub { };</dt>
	<dd>
		<p>Creates its own internal handler for both reading and writing and tries 
to do SSL handshake. </p>
		<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
		<p>On error calls back with <code>$!</code> set to some value. </p>
		<p>It's important to understand that handshaker will replace your previous 
reader and writer, so you have to create new ones.</p>
		<p>Typically it should be called inside connector's callback:</p>
<pre>    ngx_connector ... sub {

        return NGX_CLOSE 
            if $!;

        my $c = shift;

        ngx_ssl_handshaker $c, 15, sub {

            return NGX_CLOSE
                if $!;
            ...

            ngx_writer ... sub { };

            ngx_reader ... sub { };

            return NGX_WRITE;
        };

        return NGX_SSL_HANDSHAKE;
    };




</pre>
	</dd>
	<dt>ngx_resolver $name, $timeout, sub { };</dt>
	<dd>
		<p>Creates resolver's handler and tries to resolve <code>$name</code> in <code>$timeout</code>
seconds using resolver specified in <cite>nginx-perl.conf</cite>.</p>
		<p>On success returns all resolved IP addresses into <code>@_</code>.</p>
		<p>On error calls back with <code>$!</code> set to some value, $_[0] set to one of the
resolver-specific error constants and with textual explanation in $_[1]:</p>
<pre>    NGX_RESOLVE_FORMERR
    NGX_RESOLVE_SERVFAIL
    NGX_RESOLVE_NXDOMAIN
    NGX_RESOLVE_NOTIMP
    NGX_RESOLVE_REFUSED
    NGX_RESOLVE_TIMEDOUT

</pre>
		<p>This is a thin wrapper around nginx's internal resolver.
All its current problems apply. To use it in production you'll need
a local resolver, like named that does actual resolving.</p>
<pre>    ngx_resolver $host, $timeout, sub {

        if ($!) {
            my $errcode = $_[0];
            my $errstr  = $_[1];

            warn &quot;failed to resolve $host: $errstr\n&quot;;
            ...

            return;
        }

        my @IPs = @_; # list of all resolved IP addresses
        ...
    };

</pre>
	</dd>
</dl>

</div>
<h1 id="CONNECTION_TAKEOVER">CONNECTION TAKEOVER</h1>
<div id="CONNECTION_TAKEOVER_CONTENT">
<p>It is possible to takeover client connection completely and create
you own reader and writer on that connection. 
You need this for websockets and protocol upgrade in general.</p>
<p>There are two methods to support this:</p>
<dl>
	<dt>$r-&gt;take_connection()</dt>
	<dd>
		<p><code>$r-&gt;take_connection</code> initializes internal data structure and 
replaces connection's data with it. Returns <i>connection</i> on success
or <i>undef</i> on error.</p>
	</dd>
	<dt>$r-&gt;give_connection()</dt>
	<dd>
		<p><code>$r-&gt;give_connection</code> attaches request <code>$r</code> back to its connection.
Doesn't return anything.</p>
	</dd>
</dl>
<p>So, to takeover you need to take connection from the request, 
tell nginx that you are going to finalize it later by calling 
<code>$r-&gt;main_count_inc</code>, create reader and/or writer on that
connection, start reading and/or writing flow and return NGX_DONE
from your HTTP handler:</p>
<pre>    sub handler {
        my $r = shift;

        my $c = $r-&gt;take_connection()
            or return HTTP_SERVER_ERROR;

        $r-&gt;main_count_inc;

            my $buf;

            ngx_reader $c, $buf, ... , sub {

                if ($!) {
                    $r-&gt;give_connection;
                    $r-&gt;finalize_request(NGX_DONE);

                    return NGX_NOOP;
                }

                ...
            };

            ngx_writer $c, ... , sub {

                if ($!) {
                    $r-&gt;give_connection;
                    $r-&gt;finalize_request(NGX_DONE);

                    return NGX_NOOP;
                }

                ...
            };

            ngx_read($c);

        return NGX_DONE;
    }

</pre>
<p>Once you are done with the connection or connection failed with some error
you MUST give connection back to the request and finalize it:</p>
<pre>    $r-&gt;give_connection;
    $r-&gt;finalize_request(NGX_DONE);

    return NGX_NOOP;

</pre>
<p>Usually you will also need to return NGX_NOOP instead of NGX_CLOSE,
since your connection is going to be closed within http request's
finalizer. But it shouldn't cuase any problems either way.</p>

</div>
<h1 id="TIPS_AND_TRICKS">TIPS AND TRICKS</h1>
<div id="TIPS_AND_TRICKS_CONTENT">

</div>
<h2 id="SELF_SUFFICIENT_HANDLERS">SELF-SUFFICIENT HANDLERS</h2>
<div id="SELF_SUFFICIENT_HANDLERS_CONTENT">
<p>It's important to know how and actually fairly easy to create 
self-sufficient reusable handlers for <strong>nginx-perl</strong>.</p>
<p>Just remember couple of things: </p>
<p>1. Use <code>$r-&gt;location_name</code> as a prefix:</p>
<pre>    location /foo/ {
        perl_handler My::handler;
    }

    sub handler {
        ...

        my $prefix =  $r-&gt;location_name;
           $prefix =~ s/\/$//;

        $out = &quot;&lt;a href=$prefix/something &gt; do something &lt;/a&gt;&quot;;
        # will result in &quot;&lt;a href=/foo/something &gt; do something &lt;/a&gt;&quot;
        ...
    }

</pre>
<p>2. Use <code>$r-&gt;variable</code> to configure handlers and to access per-server 
and per-location variables:</p>
<pre>    location /foo/ {
        set $conf_bar &quot;baz&quot;;
        perl_handler My::handler;
    }

    sub handler {
        ...

        my $conf_bar      = $r-&gt;variable('conf_bar');
        my $document_root = $r-&gt;variable('document_root');
        ...
    }

</pre>
<p>3. Use <code>$r-&gt;ctx</code> to exchange arbitrary data between handlers:</p>
<pre>    sub handler {
        ...

        my $ctx = { foo =&gt; 'bar' };
        $r-&gt;ctx($ctx);

        my $ctx = $r-&gt;ctx;
        ...
    }

</pre>
<p>4. Use <code>perl_eval</code> to configure your modules directly 
from <cite>nginx-perl.conf</cite>:</p>
<pre>    http {

        perl_require  MyModule.pm;

        perl_eval  ' $My::CONF{foo} = &quot;bar&quot; ';
    }




    package My;

    our %CONF = ();

    sub handler {
        ...

        warn $CONF{foo};
        ...
    }

</pre>
<p>Check out <cite>eg/self-sufficient</cite> to see all this in action:</p>
<pre>    % ./objs/nginx-perl -p eg/self-sufficient

</pre>

</div>
<h1 id="SEE_ALSO">SEE ALSO</h1>
<div id="SEE_ALSO_CONTENT">
<p><a href="Nginx/Test.html">Nginx::Test</a>, <a href="Nginx/Util.html">Nginx::Util</a>, <a href="Nginx/Redis.html">Nginx::Redis</a>,
<a href="http://zzzcpan.github.com/nginx-perl">http://zzzcpan.github.com/nginx-perl</a>,
<a href="http://wiki.nginx.org/EmbeddedPerlModule">http://wiki.nginx.org/EmbeddedPerlModule</a>,
<a href="http://nginx.net/">http://nginx.net/</a> </p>

</div>
<h1 id="AUTHOR">AUTHOR</h1>
<div id="AUTHOR_CONTENT">
<p>Igor Sysoev,
Alexandr Gomoliako &lt;zzz@zzz.org.ua&gt;</p>

</div>
<h1 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h1>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright (C) Igor Sysoev</p>
<p>Copyright 2011 Alexandr Gomoliako. All rights reserved.</p>
<p>This module is free software. It may be used, redistributed and/or modified 
under the same terms as <strong>nginx</strong> itself.</p>

</div>
</div>
	</div>

	<div class="w100 centr cl blockpadtop pagepadbottom">
		<p>&copy; 2011 Alexandr Gomoliako</p>
	</div>
</div>


</body>
</html>
