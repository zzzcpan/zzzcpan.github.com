<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Nginx</title>
	<meta name="description" content="Pod documentation for Nginx" />
	<meta name="inputfile" content="&lt;standard input&gt;" />
	<meta name="outputfile" content="&lt;standard output&gt;" />
	<meta name="created" content="Mon Feb 13 20:34:40 2012" />
	<meta name="generator" content="Pod::Xhtml 1.61" />
</head>
<style type="text/css"><!--

body { color: #000000; background: #ffffff; min-width: 750px; }

body,div { margin: 0; padding: 0;}

/* layout */

div.row { width: 100%; clear: both; margin: 0; padding: 0; }

div.w100 { width: 40em; }
div.w80 { width: 35em; }

div.centr { margin: 0 auto; }

div.pagepadtop { padding-top: 80px; }
div.pagepadbottom { padding-bottom: 80px; }
div.blockpadtop { padding-top: 10px; }
div.blockpadbottom { padding-bottom: 20px; }

div.cl { clear: both; }
div.fl { float: left; }
div.fr { float: right; }
div.ab { position: absolute; }
div.rl { position: relative; }

div.ph { height: 1px; line-height: 1px; overflow: hidden; } /* placeholder */


/* special, shifting logo a bit left */

div.hlogo { height: 42px; }
div.m2 { margin-left: -2px; }
div.hlogos { height: 29px; }
div.m1 { margin-left: -1px; }

/* links, nv class to avoid highlighting visited links */

a.nv:visited { color: #007a03; }
a.nv:focus, a.nv:hover { color: #f54b00; }
a { color: #007a03; }
a:visited { color: #990099; }
a:focus, a:hover { color: #f54b00; }



/* text */

h1 { font-size: 196%;   font-weight: normal; font-style: normal; }
h2 { font-size: 167%;   font-weight: normal; font-style: normal; }
h3 { font-size: 146.5%; font-weight: normal; font-style: normal; }
h4 { font-size: 123.1%; font-weight: normal; font-style: normal; }
h5 { font-size: 108%;   font-weight: bold;   font-style: normal; }
h6 { font-size: 108%;   font-weight: normal; font-style: italic; }

h1,h2,h3,h4,h5,h6,p,div,ul,li,a,span,b,strong,i { font-family: "Times New Roman", Times; }
a,span,b,strong,i { margin: 0; padding: 0; }
h1,h2,h3,h4,h5,h6,p { padding: 0.5em 0 0.5em 0; }
p { line-height: 1.3em } 
p { margin: 0 0 -0em 0; }
h1,h2 { margin: 0.4em 0 -0.4em 0;  }
h3,h4,h5,h6 { margin: 0.6em 0 -0.6em 0;  }

ul.nls { list-style: none; }

div.pod div { padding: 0 1.7em; }
div.pod ul { list-style: none; }
div.pod ul li a { text-decoration: none; }


--></style>

<body>

<div class="row">

	<div class="w100 centr cl pagepadtop blockpadbottom rl hlogos">
		<div class="ab m2 hlogos">
			<a href="index.html" title="nginx-perl"><img 
				src="nginx-perl.gif" border="0"
				alt="nginx-perl" /></a>
		</div>
	</div>

	<div class="w100 centr cl blockpadbottom">

		<h3>Documentation</h3>

		<p><b>Nginx</b> &nbsp;&nbsp; <a href="Nginx/Test.html">Nginx::Test</a> &nbsp;&nbsp; <a href="Nginx/Redis.html">Nginx::Redis</a> &nbsp;&nbsp; <a href="Nginx/HTTP.html">Nginx::HTTP</a> &nbsp;&nbsp; </p>
	</div>

	<div class="w100 centr cl blockpadtop blockpadbottom">




<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Nginx</h3>

<ul><li><a href="#NAME">NAME</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#RATIONALE">RATIONALE</a></li>
<li><a href="#INSTALLATION">INSTALLATION</a></li>
<li><a href="#RUNNING_EXAMPLES">RUNNING EXAMPLES</a></li>
<li><a href="#BENCHMARKING">BENCHMARKING</a></li>
<li><a href="#CONFIGURATION_DIRECTIVES">CONFIGURATION DIRECTIVES</a></li>
<li><a href="#INTERNAL_FUNCTIONS">INTERNAL FUNCTIONS</a>
<ul>
<li>
<ul><li><a href="#code_uri_ngx_escape_uri_src_uri_type"><code>$uri = ngx_escape_uri $src_uri, $type</code>;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#HTTP_API">HTTP API</a>
<ul><li><a href="#CONTENT_HANDLER">CONTENT HANDLER</a></li>
<li><a href="#ACCESS_HANDLER">ACCESS HANDLER</a></li>
<li><a href="#METHODS">METHODS</a>
<ul><li><a href="#code_r_gt_status_status_code"><code>$r-&gt;status($status)</code></a></li>
<li><a href="#code_r_gt_send_http_header_content_t"><code>$r-&gt;send_http_header($content_type)</code></a></li>
<li><a href="#code_r_gt_header_only_code"><code>$r-&gt;header_only</code></a></li>
<li><a href="#code_r_gt_uri_code"><code>$r-&gt;uri</code></a></li>
<li><a href="#code_r_gt_args_code"><code>$r-&gt;args</code></a></li>
<li><a href="#code_r_gt_request_method_code"><code>$r-&gt;request_method</code></a></li>
<li><a href="#code_r_gt_remote_addr_code"><code>$r-&gt;remote_addr</code></a></li>
<li><a href="#code_ctx_r_gt_ctx_ctx_code"><code>$ctx = $r-&gt;ctx($ctx)</code></a></li>
<li><a href="#code_r_gt_location_name_code"><code>$r-&gt;location_name</code></a></li>
<li><a href="#code_r_gt_root_code"><code>$r-&gt;root</code></a></li>
<li><a href="#code_r_gt_header_in_quot_User_Agent_"><code>$r-&gt;header_in(&quot;User-Agent&quot;)</code></a></li>
<li><a href="#code_r_gt_headers_in_code"><code>$r-&gt;headers_in</code></a></li>
<li><a href="#code_r_gt_has_request_body_amp_handl"><code>$r-&gt;has_request_body(\&amp;handler)</code></a></li>
<li><a href="#code_r_gt_request_body_code"><code>$r-&gt;request_body</code></a></li>
<li><a href="#code_r_gt_request_body_file_code"><code>$r-&gt;request_body_file</code></a></li>
<li><a href="#code_r_gt_discard_request_body_code"><code>$r-&gt;discard_request_body</code></a></li>
<li><a href="#code_r_gt_header_out_name_value_code"><code>$r-&gt;header_out($name, $value)</code></a></li>
<li><a href="#code_r_gt_filename_code"><code>$r-&gt;filename</code></a></li>
<li><a href="#code_r_gt_print_data_code"><code>$r-&gt;print($data, ...)</code></a></li>
<li><a href="#code_r_gt_sendfile_filename_offset_l"><code>$r-&gt;sendfile($filename, $offset, $length)</code></a></li>
<li><a href="#code_r_gt_flush_code"><code>$r-&gt;flush</code></a></li>
<li><a href="#code_r_gt_internal_redirect_uri_code"><code>$r-&gt;internal_redirect($uri)</code></a></li>
<li><a href="#code_r_gt_allow_ranges_code"><code>$r-&gt;allow_ranges</code></a></li>
<li><a href="#code_r_gt_unescape_data_code"><code>$r-&gt;unescape($data)</code></a></li>
<li><a href="#code_r_gt_variable_name_value_code"><code>$r-&gt;variable($name, $value)</code></a></li>
<li><a href="#code_r_gt_log_error_errno_message_co"><code>$r-&gt;log_error($errno, $message)</code></a></li>
<li><a href="#code_r_gt_main_count_inc_code"><code>$r-&gt;main_count_inc()</code></a></li>
<li><a href="#code_r_gt_send_special_rc_code"><code>$r-&gt;send_special($rc)</code></a></li>
<li><a href="#code_r_gt_finalize_request_rc_code"><code>$r-&gt;finalize_request($rc)</code></a></li>
<li><a href="#code_r_gt_phase_handler_inc_code"><code>$r-&gt;phase_handler_inc()</code></a></li>
<li><a href="#code_r_gt_core_run_phases_code"><code>$r-&gt;core_run_phases()</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ASYNCHRONOUS_API">ASYNCHRONOUS API</a>
<ul><li><a href="#NAMING">NAMING</a></li>
<li><a href="#FLOW_CONTROL">FLOW CONTROL</a></li>
<li><a href="#ERROR_HANDLING">ERROR HANDLING</a></li>
<li><a href="#FUNCTIONS">FUNCTIONS</a>
<ul><li><a href="#code_ngx_timer_after_repeat_sub_code"><code>ngx_timer $after, $repeat, sub { };</code></a></li>
<li><a href="#code_ngx_connector_ip_port_timeout_s"><code>ngx_connector $ip, $port, $timeout, sub { };</code></a></li>
<li><a href="#code_ngx_reader_c_buf_min_max_timeou"><code>ngx_reader $c, $buf, $min, $max, $timeout, sub { };</code></a></li>
<li><a href="#code_ngx_writer_c_buf_timeout_sub_co"><code>ngx_writer $c, $buf, $timeout, sub { };</code></a></li>
<li><a href="#code_ngx_ssl_handshaker_c_timeout_su"><code>ngx_ssl_handshaker $c, $timeout, sub { };</code></a></li>
<li><a href="#code_ngx_resolver_name_timeout_sub_c"><code>ngx_resolver $name, $timeout, sub { };</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#CONNECTION_TAKEOVER">CONNECTION TAKEOVER</a>
<ul><li><a href="#METHODS-2">METHODS</a>
<ul><li><a href="#code_r_gt_take_connection_code"><code>$r-&gt;take_connection</code></a></li>
<li><a href="#code_r_gt_give_connection_code"><code>$r-&gt;give_connection</code></a></li>
</ul>
</li>
<li><a href="#TAKEOVER">TAKEOVER</a></li>
</ul>
</li>
<li><a href="#TIPS_AND_TRICKS">TIPS AND TRICKS</a>
<ul><li><a href="#SELF_SUFFICIENT_HANDLERS">SELF-SUFFICIENT HANDLERS</a></li>
</ul>
</li>
<li><a href="#SEE_ALSO">SEE ALSO</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><hr />
<!-- INDEX END -->

<h1 id="NAME">NAME</h1>
<div id="NAME_CONTENT">
<p>Nginx - full-featured perl support for nginx</p>

</div>
<h1 id="SYNOPSIS">SYNOPSIS</h1>
<div id="SYNOPSIS_CONTENT">
<pre>    use Nginx;

    # nginx's asynchronous resolver
    #     &quot;resolver 1.2.3.4;&quot; in nginx-perl.conf

    ngx_resolver &quot;www.google.com&quot;, 15, sub {
        my (@IPs) = @_;

        if ($!) {
            my ($errcode, $errstr) = @_;
            ngx_log_error $!, &quot;Cannot resolve google's IP: $errstr&quot;;
        }
    };

    # timer

    ngx_timer 5, 0, sub {
        ngx_log_notice 0, &quot;5 seconds gone&quot;;
    };

    # asynchronous connections
    # with explicit flow control

    ngx_connector &quot;1.2.3.4&quot;, 80, 15, sub {
        if ($!) {
            ngx_log_error $!, &quot;Connect error: $!&quot;;
            return NGX_CLOSE;
        }

        my $c = shift;  # connection
        my $wbuf = &quot;GET /\x0d\x0a&quot;;
        my $rbuf;

        ngx_writer $c, $wbuf, 15, sub {
            if ($!) {
                ngx_log_error $!, &quot;Write error: $!&quot;;
                return NGX_CLOSE;
            }

            return NGX_READ;
        };

        ngx_reader $c, $rbuf, 0, 0, 15, sub {
            if ($! &amp;&amp; $! != NGX_EOF) { 
                ngx_log_error $!, &quot;Read error: $!&quot;;
                return NGX_CLOSE;
            }

            if ($! == NGX_EOF) {
                ngx_log_info 0, &quot;response length: &quot; . length ($rbuf);
                return NGX_CLOSE;
            }

            return NGX_READ;  # no errors - read again
        };

        return NGX_WRITE;  # what to do on connect
    };

    # SSL handshake

    ngx_connector &quot;1.2.3.4&quot;, 80, 15, sub {
        ...
        my $c = shift;

        ngx_ssl_handshaker $c, 15, sub {
            ...
            ngx_writer $c, $wbuf, 15, sub {
                ...
            };

            ngx_reader $c, $rbuf, 0, 0, 15, sub {
                ...
            };

            return NGX_WRITE;
        };

        return NGX_SSL_HANDSHAKE;
    };

    # asynchronous response
    # via HTTP API

    sub handler {
        my ($r) = shift;

        $r-&gt;main_count_inc;

        ngx_resolver &quot;www.google.com&quot;, 15, sub {

            $r-&gt;send_http_header ('text/html');

            unless ($!) {
                lcoal $, = ', ';
                $r-&gt;print (&quot;OK, @_\n&quot;);
            } else {
                $r-&gt;print (&quot;FAILED, $_[1]\n&quot;);
            }

            $r-&gt;send_special (NGX_HTTP_LAST);
            $r-&gt;finalize_request (NGX_OK);
        };

        return NGX_DONE;
    }

    # and more... 

</pre>
<p><cite>nginx-perl.conf</cite>:</p>
<pre>    http {

        perl_inc      /path/to/lib;
        perl_inc      /path/to/apps;
        perl_require  My/App.pm;

        perl_init_worker  My::App::init_worker;
        perl_exit_worker  My::App::exit_worker;

        perl_eval  '$My::App::SOME_VAR = &quot;foo&quot;';
        ...

        server {
            location / {
                perl_handler  My::App::handler;
        ...

</pre>
<p><cite>My/App.pm</cite>:</p>
<pre>    package My::App;

    use Nginx;

    sub handler {
        my $r = shift;
        ...
    }
    ...

</pre>

</div>
<h1 id="DESCRIPTION">DESCRIPTION</h1>
<div id="DESCRIPTION_CONTENT">
<p>Nginx with capital <i>N</i> is a part of <strong>nginx-perl</strong> distribution.</p>
<p>Nginx-perl brings asynchronous functions and other useful features 
into embedded perl to turn it into nice and powerful perl web server.</p>

</div>
<h1 id="RATIONALE">RATIONALE</h1>
<div id="RATIONALE_CONTENT">
<p>Nginx is very popular and stable asynchronous web-server.
And reusing as much of its internals as possible gives this project 
same level of stability nginx has. Maybe not right from the beginning,
but it can catch up with a very little effort.</p>
<p>Internal HTTP parser, dispatcher (locations) and different types
of handlers free perl modules from reinventing all that, like most 
of the perl frameworks do. It's already there, native and extremely
fast. </p>
<p>All of the output filters there as well and everything you do
can be gzipped, processed with xslt or through any filter module
for nginx. Again, extremely fast.</p>
<p>Nginx has a pretty decent master-worker model, which allows to do
process management right out of the box.</p>
<p>And probably some other things I can't remember at the moment.</p>
<p>So, why use any of those perl frameworks if we already have 
nginx with nice native implementation for almost everything
they offer. It just needed a little touch.</p>
<p>Additionally I wanted to implement new asynchronous API
with proper flow control and explicit parameters to avoid
complexity as much as possible. </p>

</div>
<h1 id="INSTALLATION">INSTALLATION</h1>
<div id="INSTALLATION_CONTENT">
<p>As usual for perl extensions:</p>
<pre>    % perl Makefile.PL
    % make
    % make test
    % make install

</pre>
<p><cite>Makefile.PL</cite> supports everything <cite>./configure</cite> does. 
To build it with SSL support use something like:</p>
<pre>    % perl Makefile.PL --with-http_ssl_module

</pre>
<p>Or if you want to install it into different perl simply run <cite>Makefile.PL</cite>
undef it:</p>
<pre>    % /home/zzz/perl5/perlbrew/perls/perl-5.14.2/bin/perl Makefile.PL

</pre>
<p>It is safe to install nginx-perl alongside nginx. It uses 
capital <strong>N</strong> for perl modules and <cite>nginx-perl</cite> for binaries.</p>

</div>
<h1 id="RUNNING_EXAMPLES">RUNNING EXAMPLES</h1>
<div id="RUNNING_EXAMPLES_CONTENT">
<p>You don't have to install nginx-perl to try it. There are couple
of ready to try examples in <cite>eg/</cite>:</p>
<pre>    % ./objs/nginx-perl -p eg/helloworld

</pre>
<p>Now open another terminal or your web browser and go to
http://127.0.0.1:55555/ or whatever IP you're on.</p>

</div>
<h1 id="BENCHMARKING">BENCHMARKING</h1>
<div id="BENCHMARKING_CONTENT">
<p>The easiest way to benchmark nginx-perl against node.js is to run
redis example from <cite>eg/redis</cite>, <cite>eg/redis.js</cite> and compare the results. 
But first you need to install <a href="Redis/Parser/XS.html">Redis::Parser::XS</a> from cpan:</p>
<pre>    % cpan Redis::Parser::XS
    ...
    % ./objs/nginx-perl -p eg/redis
    ...

    % ab -c10 -n10000 http://127.0.0.1:55555/
    % ab -c10 -n10000 http://127.0.0.1:55555/single
    % ab -c10 -n10000 http://127.0.0.1:55555/multi

</pre>
<p>Same goes for node.js:</p>
<pre>    % npm install redis
    % npm install hiredis
    ...
    % node eg/redis.js
    ...

    % ab -c10 -n10000 http://127.0.0.1:55555/
    % ab -c10 -n10000 http://127.0.0.1:55555/single
    % ab -c10 -n10000 http://127.0.0.1:55555/multi

</pre>

</div>
<h1 id="CONFIGURATION_DIRECTIVES">CONFIGURATION DIRECTIVES</h1>
<div id="CONFIGURATION_DIRECTIVES_CONTENT">
<dl>
	<dt>perl_inc  /path/to/lib;</dt>
	<dd>
		<p>Works just like Perl's <code>use lib '/path/to/lib'</code>. Supports only one
argument, but you can specify it multiple times.</p>
<pre>    http {
        perl_inc  /path/to/lib;
        perl_inc  /path/to/myproject/lib;




</pre>
	</dd>
	<dt>perl_require  My/App.pm;</dt>
	<dd>
		<p>Same as Perl's own <code>require</code>.</p>
<pre>    http {
        perl_inc      /path/to/lib;
        perl_require  My/App.pm;

</pre>
	</dd>
	<dt>perl_init_worker  My::App::init_worker;</dt>
	<dd>
		<p>Adds a handler to call on worker's start.</p>
<pre>    http {
        perl_inc          /path/to/lib;
        perl_require      My/App.pm;

        perl_init_worker  My::App::init_worker;
        perl_init_worker  My::AnotherApp::init_worker;

</pre>
	</dd>
	<dt>perl_exit_worker  My::App::exit_worker;</dt>
	<dd>
		<p>Adds a handler to call on worker's exit.</p>
<pre>    http {
        perl_inc          /path/to/lib;
        perl_require      My/App.pm;

        perl_exit_worker  My::App::exit_worker;
        perl_exit_worker  My::AnotherApp::exit_worker;

</pre>
	</dd>
	<dt>perl_handler  My::App::handler; </dt>
	<dd>
		<p>Sets current location's http content handler (a.k.a. http handler).</p>
<pre>    http {
        server {
            location / {
                perl_handler My::App::Handler;




</pre>
	</dd>
	<dt>perl_access  My::App::access_handler; </dt>
	<dd>
		<p>Adds an http access handler to the access phase of current location.</p>
<pre>    http {
        server {
            location / {
                perl_access My::App::access_handler; 
                perl_handler My::App::Handler;

</pre>
	</dd>
	<dt>perl_eval  '$My::App::CONF{foo} = &quot;bar&quot;';</dt>
	<dd>
		<p>Evaluates some perl code on configuration level. Useful if you 
need to configure some perl modules directly fron <cite>nginx-perl.conf</cite>.</p>
<pre>    http {
        perl_eval  '$My::App::CONF{foo} = &quot;bar&quot;';

</pre>
	</dd>
	<dt>perl_app  /path/to/app.pl;</dt>
	<dd>
		<p>Sets http content handler to the <code>sub { }</code> returned from
the app. Internally does simple <code>$handler = do '/path/to/app.pl'</code>,
so you can put your app into @INC somewhere to get shorter path.
Additionally prereads entire request body before calling the handler.
Which means there is no need to call $r-&gt;has_request_body there.</p>
<pre>    http {
        server {
            location / {
                perl_app  /path/to/app.pl;

</pre>
	</dd>
</dl>

</div>
<h1 id="INTERNAL_FUNCTIONS">INTERNAL FUNCTIONS</h1>
<div id="INTERNAL_FUNCTIONS_CONTENT">

</div>
<h3 id="code_uri_ngx_escape_uri_src_uri_type"><code>$uri = ngx_escape_uri $src_uri, $type</code>;</h3>
<div id="code_uri_ngx_escape_uri_src_uri_type-2">
<p>Escapes <code>$src_uri</code> using internal <code>ngx_escape_uri</code> function from 
<cite>src/core/ngx_string.c</cite>. If <code>$type</code> is specified, uses it or 
NGX_ESCAPE_URI otherwise.</p>
<pre>    my $foo = ngx_escape_uri 'a b';
      # gives 'a%20b'

    my $foo = ngx_escape_uri 'a b', NGX_ESCAPE_URI;

</pre>
<p>Type defines what characters to escape. </p>
<pre>    NGX_ESCAPE_URI                &quot; &quot;, &quot;#&quot;, &quot;%&quot;, &quot;?&quot;, 
                                  %00-%1F, %7F-%FF

    NGX_ESCAPE_ARGS               &quot; &quot;, &quot;#&quot;, &quot;%&quot;, &quot;&amp;&quot;, &quot;+&quot;, &quot;?&quot;, 
                                  %00-%1F, %7F-%FF 

    NGX_ESCAPE_URI_COMPONENT      everything except: 
                                   ALPHA, DIGIT, &quot;-&quot;, &quot;.&quot;, &quot;_&quot;, &quot;~&quot;

    NGX_ESCAPE_HTML               &quot; &quot;, &quot;#&quot;, &quot;&quot;&quot;, &quot;%&quot;, &quot;'&quot;, 
                                  %00-%1F, %7F-%FF

    NGX_ESCAPE_REFRESH            &quot; &quot;, &quot;&quot;&quot;, &quot;%&quot;, &quot;'&quot;, 
                                  %00-%1F, %7F-%FF

    NGX_ESCAPE_MEMCACHED          &quot; &quot;, &quot;%&quot;, %00-%1F

</pre>

</div>
<h1 id="HTTP_API">HTTP API</h1>
<div id="HTTP_API_CONTENT">

</div>
<h2 id="CONTENT_HANDLER">CONTENT HANDLER</h2>
<div id="CONTENT_HANDLER_CONTENT">
<p>This is where response should get generated and send to the client.
Here's how to send response completely asynchronously:</p>
<pre>    sub handler {
        my $r = shift;

        $r-&gt;main_count_inc;

        ngx_timer 1, 0, sub {
            $r-&gt;send_http_header('text/html');
            $r-&gt;print(&quot;OK\n&quot;);

            $r-&gt;send_special(NGX_HTTP_LAST);
            $r-&gt;finalize_request(NGX_OK);
        };

        return NGX_DONE;
    }

</pre>
<p>Notice <code>return NGX_DONE</code> instead of <code>return OK</code>, this is important,
because it allows to avoid post processing response the old way.</p>

</div>
<h2 id="ACCESS_HANDLER">ACCESS HANDLER</h2>
<div id="ACCESS_HANDLER_CONTENT">
<p>Access handler is a perfect place for access control. Return <code>NGX_OK</code>
to allow access or some HTTP error to deny:</p>
<pre>    sub access_handler {
        my ($r) = @_;

        if ($r-&gt;uri eq '/private') {
            return 403;
        }

        return NGX_OK;
    }

</pre>
<p>It is also possible to do something asynchronously, as with content handler,
but a bit differently. On success we have to pass request to the next
phase handler but finalize it on error. As before, <code>NGX_DONE</code> means 
that we are going to process request ourselves. So, let's rewrite first 
example but make it suitable for asynchronous execution:</p>
<pre>    sub access_handler {
        my ($r) = @_;

        if ($r-&gt;uri eq '/private') {
            $r-&gt;finazlie_request(403);
            return NGX_DONE;
        }

        $r-&gt;phase_handler_inc;
        $r-&gt;core_run_phases;
        return NGX_DONE;
    }

</pre>
<p>Now it is possible to use timer or redis client or any other asynchronous
function:</p>
<pre>    sub access_handler {
        my ($r) = @_;

        ngx_timer 1, 0, sub {

            if ($r-&gt;uri eq '/private') {
                $r-&gt;finalize_request(403);
                return;
            } 

            $r-&gt;phase_handler_inc;
            $r-&gt;core_run_phases;
        };

        return NGX_DONE;
    }

</pre>
<p>One of the interesting things you can do with it is putting username into 
internal variable:</p>
<pre>    sub access_handler {
        my ($r) = @_;

        ngx_timer 1, 0, sub {

            $r-&gt;variable(&quot;my_username&quot;, &quot;foobar&quot;);

            $r-&gt;phase_handler_inc;
            $r-&gt;core_run_phases;
        };

        return NGX_DONE;
    }

</pre>
<p>It allows you to pass this variable to the upstream as a header
or use it in any other way in configuration:</p>
<pre>    server {
        set $my_username &quot;guest&quot;;

        location / {
            perl_access  Foo::access_handler;

            proxy_pass        http://1.2.3.4:5678; 
            proxy_set_header  X-My-Username  $my_username;
        }
    }

</pre>
<p>Be aware that nginx might call access handler more than once depending
on your configuration. And if you are using redis for this you should
consider caching reply even for a little time.</p>

</div>
<h2 id="METHODS">METHODS</h2>
<div id="METHODS_CONTENT">
<p>Most of the following methods are available for both original embedded perl
and nginx-perl. </p>

</div>
<h3 id="code_r_gt_status_status_code"><code>$r-&gt;status($status)</code></h3>
<div id="code_r_gt_status_status_code_CONTENT">
<p>Sets response status. </p>
<pre>    $r-&gt;status(404);

</pre>

</div>
<h3 id="code_r_gt_send_http_header_content_t"><code>$r-&gt;send_http_header($content_type)</code></h3>
<div id="code_r_gt_send_http_header_content_t-2">
<p>Sends http headers of the response. If <code>$content_type</code> is given sets
content type of the response.</p>
<pre>    $r-&gt;send_http_header(&quot;text/html; charset=UTF-8&quot;);

</pre>

</div>
<h3 id="code_r_gt_header_only_code"><code>$r-&gt;header_only</code></h3>
<div id="code_r_gt_header_only_code_CONTENT">
<p>Returns true if client expects only header of the response, e.g. HEAD request.</p>
<pre>    unless ($r-&gt;header_only) {
        $r-&gt;print(&quot;hello world&quot;);
    }

</pre>

</div>
<h3 id="code_r_gt_uri_code"><code>$r-&gt;uri</code></h3>
<div id="code_r_gt_uri_code_CONTENT">
<p>Returns normalized uri of the request without query string. Unparsed uri
available through either new method <code>$r-&gt;unparsed_uri</code> or internal
variable <code>$r-&gt;variable(&quot;request_uri&quot;)</code>.</p>

</div>
<h3 id="code_r_gt_args_code"><code>$r-&gt;args</code></h3>
<div id="code_r_gt_args_code_CONTENT">
<p>This is just a query string. </p>

</div>
<h3 id="code_r_gt_request_method_code"><code>$r-&gt;request_method</code></h3>
<div id="code_r_gt_request_method_code_CONTEN">
<p>Returns HTTP request method. As usual GET, HEAD, POST, etc.</p>

</div>
<h3 id="code_r_gt_remote_addr_code"><code>$r-&gt;remote_addr</code></h3>
<div id="code_r_gt_remote_addr_code_CONTENT">
<p>Returns textual representation of remote address.</p>

</div>
<h3 id="code_ctx_r_gt_ctx_ctx_code"><code>$ctx = $r-&gt;ctx($ctx)</code></h3>
<div id="code_ctx_r_gt_ctx_ctx_code_CONTENT">
<p>Sets and gets some context scalar. It will be useful to get some data 
from access handler for example.</p>

</div>
<h3 id="code_r_gt_location_name_code"><code>$r-&gt;location_name</code></h3>
<div id="code_r_gt_location_name_code_CONTENT">
<p>Returns the name of the location. </p>
<pre>    location /foo {
        perl_handler ...;
    }

    my $loc = $r-&gt;location_name;    
    # $loc = '/foo'

</pre>

</div>
<h3 id="code_r_gt_root_code"><code>$r-&gt;root</code></h3>
<div id="code_r_gt_root_code_CONTENT">
<p>Returns the root path.</p>

</div>
<h3 id="code_r_gt_header_in_quot_User_Agent_"><code>$r-&gt;header_in(&quot;User-Agent&quot;)</code></h3>
<div id="code_r_gt_header_in_quot_User_Agent_-2">
<p>Returns desired HTTP header. Case doesn't matter. If you want to get
all of the headers take a look at one of the new methods: 
<code>$r-&gt;headers_in</code>.</p>

</div>
<h3 id="code_r_gt_headers_in_code"><code>$r-&gt;headers_in</code></h3>
<div id="code_r_gt_headers_in_code_CONTENT">
<p>Returns all headers in the following form:</p>
<pre>    {  content-type   =&gt; ['text/html'],
       content-length =&gt; [1234]          }

</pre>

</div>
<h3 id="code_r_gt_has_request_body_amp_handl"><code>$r-&gt;has_request_body(\&amp;handler)</code></h3>
<div id="code_r_gt_has_request_body_amp_handl-2">
<p>Returns true if there is a request body to be read and sets the handler 
to call when done or false otherwise. And if there is a body you should
return from current handler and continue in the new one. </p>
<pre>    sub handler {
        my ($r) = @_;

        if ( $r-&gt;has_request_body(\&amp;handler_with_body) ) {
            return OK;
        }

        ...
    }

    sub handler_with_body {
        my ($r) = @_;

        my $body = $r-&gt;request_body;
        ...
    }

</pre>

</div>
<h3 id="code_r_gt_request_body_code"><code>$r-&gt;request_body</code></h3>
<div id="code_r_gt_request_body_code_CONTENT">
<p>Returns request body if it is stored in memory or undef otherwise.
By default request body will be read into memory if it is less than 
<code>client_body_buffer_size</code> and <code>client_max_body_size</code>. You can change
them in <cite>nginx-perl.conf</cite>.</p>

</div>
<h3 id="code_r_gt_request_body_file_code"><code>$r-&gt;request_body_file</code></h3>
<div id="code_r_gt_request_body_file_code_CON">
<p>If request body doesn't fit into <code>client_body_buffer_size</code> it is stored
in temporary file. You can read it yourself.</p>
<pre>    sub handler_with_body {
        my ($r) = @_;
        my $filename = $r-&gt;request_body_file;

        if (open $fh, '&lt;', $filename) {
            ...
        }
    }

</pre>

</div>
<h3 id="code_r_gt_discard_request_body_code"><code>$r-&gt;discard_request_body</code></h3>
<div id="code_r_gt_discard_request_body_code_">
<p>Tells nginx to ignore request body. </p>

</div>
<h3 id="code_r_gt_header_out_name_value_code"><code>$r-&gt;header_out($name, $value)</code></h3>
<div id="code_r_gt_header_out_name_value_code-2">
<p>Adds HTTP header <code>&quot;$name: $value&quot;</code> to the response.</p>

</div>
<h3 id="code_r_gt_filename_code"><code>$r-&gt;filename</code></h3>
<div id="code_r_gt_filename_code_CONTENT">
<p>Returns the name of the file translated from URI. </p>

</div>
<h3 id="code_r_gt_print_data_code"><code>$r-&gt;print($data, ...)</code></h3>
<div id="code_r_gt_print_data_code_CONTENT">
<p>Sends <code>$data</code> to the client. Make sure to send HTTP header before
you use this function.</p>

</div>
<h3 id="code_r_gt_sendfile_filename_offset_l"><code>$r-&gt;sendfile($filename, $offset, $length)</code></h3>
<div id="code_r_gt_sendfile_filename_offset_l-2">
<p>Kind of like print, buf sends a static file instead. If <code>$offset</code> and
<code>$length</code> are specified uses them. Actual sending happens later.</p>
<p>If you have <code>sendfile on;</code> in your <cite>nginx-perl.conf</cite> it will bypass
output filters like gzip.</p>

</div>
<h3 id="code_r_gt_flush_code"><code>$r-&gt;flush</code></h3>
<div id="code_r_gt_flush_code_CONTENT">
<p>Forces nginx to start sending data to the client.</p>

</div>
<h3 id="code_r_gt_internal_redirect_uri_code"><code>$r-&gt;internal_redirect($uri)</code></h3>
<div id="code_r_gt_internal_redirect_uri_code-2">
<p>Performs internal redirect to <code>$uri</code>. You can use it with original handler
only, i.e. you have to return <code>OK</code> after this call. </p>
<p>It might change in the future.</p>

</div>
<h3 id="code_r_gt_allow_ranges_code"><code>$r-&gt;allow_ranges</code></h3>
<div id="code_r_gt_allow_ranges_code_CONTENT">
<p>Allows nginx to handle byte ranges in the response.</p>

</div>
<h3 id="code_r_gt_unescape_data_code"><code>$r-&gt;unescape($data)</code></h3>
<div id="code_r_gt_unescape_data_code_CONTENT">
<p>Unescapes URI escaped data (<code>&quot;%XX&quot;</code>). </p>

</div>
<h3 id="code_r_gt_variable_name_value_code"><code>$r-&gt;variable($name, $value)</code></h3>
<div id="code_r_gt_variable_name_value_code_C">
<p>Gets and sets internal variables, the ones that you can see in config.</p>

</div>
<h3 id="code_r_gt_log_error_errno_message_co"><code>$r-&gt;log_error($errno, $message)</code></h3>
<div id="code_r_gt_log_error_errno_message_co-2">
<p>Logs error message using current connection's log. </p>

</div>
<h3 id="code_r_gt_main_count_inc_code"><code>$r-&gt;main_count_inc()</code></h3>
<div id="code_r_gt_main_count_inc_code_CONTEN">
<p>Increases value of an internal <code>r-&gt;main-&gt;count</code> by 1 and
therefore allows to send response later from some other callback.</p>

</div>
<h3 id="code_r_gt_send_special_rc_code"><code>$r-&gt;send_special($rc)</code></h3>
<div id="code_r_gt_send_special_rc_code_CONTE">
<p>Sends response in a special way. We are using this function
to send response asynchronously from non-http handlers.</p>
<pre>    ngx_timer 1, 0, sub {
        $r-&gt;send_http_header('text/html');
        $r-&gt;print(&quot;OK\n&quot;);

        $r-&gt;send_special(NGX_HTTP_LAST);
        $r-&gt;finalize_request(NGX_OK);
    };

</pre>

</div>
<h3 id="code_r_gt_finalize_request_rc_code"><code>$r-&gt;finalize_request($rc)</code></h3>
<div id="code_r_gt_finalize_request_rc_code_C">
<p>Decreases <code>r-&gt;main-&gt;count</code> and finalizes request.</p>

</div>
<h3 id="code_r_gt_phase_handler_inc_code"><code>$r-&gt;phase_handler_inc()</code></h3>
<div id="code_r_gt_phase_handler_inc_code_CON">
<p>Allows to move to the next phase handler from access handler.</p>

</div>
<h3 id="code_r_gt_core_run_phases_code"><code>$r-&gt;core_run_phases()</code></h3>
<div id="code_r_gt_core_run_phases_code_CONTE">
<p>Allows to break out of access handler and continue later from
some other callback.</p>

</div>
<h1 id="ASYNCHRONOUS_API">ASYNCHRONOUS API</h1>
<div id="ASYNCHRONOUS_API_CONTENT">

</div>
<h2 id="NAMING">NAMING</h2>
<div id="NAMING_CONTENT">
<pre>    NGX_FOO_BAR  -- constants
    ngx_*r       -- asynchronous functions (creators)
    NGX_VERB     -- flow control constants 
    ngx_verb     -- flow control functions
    $r-&gt;foo_bar  -- request object's methods

</pre>
<p>Each asynchronous function has an <strong>r</strong> at the end of its name. This is 
because those functions are creators of handlers with some parameters. 
E.g. ngx_writer creates write handler for some connection with some
scalar as a buffer.</p>

</div>
<h2 id="FLOW_CONTROL">FLOW CONTROL</h2>
<div id="FLOW_CONTROL_CONTENT">
<p>To specify what to do after each callback we can either call some 
function or return some value and let handler do it for us. 
Most of the ngx_* handlers support return value and even optimized
for that kind of behavior.</p>
<p>Functions take connection as an argument:</p>
<pre>    ngx_read($c)
    ngx_write($c)
    ngx_ssl_handshake($c)
    ngx_close($c)

</pre>
<p>Return values only work on current connection:</p>
<pre>    return NGX_READ;
    return NGX_WRITE;
    return NGX_SSL_HANDSHAKE;
    return NGX_CLOSE;

</pre>
<p>As an example, let's connect and close connection. We will do flow control 
via single <code>return</code> for this:</p>
<pre>    ngx_connector '1.2.3.4', 80, 15, sub {

        return NGX_CLOSE;
    };

</pre>
<p>Now, if we want to connect and then read exactly 10 bytes we need
to create reader and <code>return NGX_READ</code> from connector's callback:</p>
<pre>    ngx_connector '1.2.3.4', 80, 15, sub {

        my $c = shift;

        ngx_reader $c, $buf, 10, 10, 15, sub {
            ... 
        };

        return NGX_READ;
    };

</pre>
<p>This will be different, if we already have connection somehow:</p>
<pre>    ngx_reader $c, $buf, 10, 10, 15, sub {
        ... 
    };

    ngx_read($c);

</pre>

</div>
<h2 id="ERROR_HANDLING">ERROR HANDLING</h2>
<div id="ERROR_HANDLING_CONTENT">
<p>Each ngx_* handler will call back on any error with <code>$!</code> set to some value
and reset to 0 otherwise. 
For simplicity EOF considered to be an error as well and <code>$!</code> will be set
to NGX_EOF in such case. </p>
<p>Example:</p>
<pre>    ngx_reader $c, $buf, 0, 0, sub {

        return NGX_WRITE
            if $! == NGX_EOF;

        return NGX_CLOSE
            if $!;
        ...
    };

</pre>

</div>
<h2 id="FUNCTIONS">FUNCTIONS</h2>
<div id="FUNCTIONS_CONTENT">

</div>
<h3 id="code_ngx_timer_after_repeat_sub_code"><code>ngx_timer $after, $repeat, sub { };</code></h3>
<div id="code_ngx_timer_after_repeat_sub_code-2">
<p>Creates new timer and calls back after <code>$after</code> seconds.
If <code>$repeat</code> is set reschedules the timer to call back again after 
<code>$repeat</code> seconds or destroys it otherwise.</p>
<p>Internally <code>$repeat</code> is stored as a refence, so changing it will influence
rescheduling behaviour.</p>
<p>Simple example calls back just once after 1 second:</p>
<pre>    ngx_timer 1, 0, sub {
        warn &quot;tada\n&quot;;
    };

</pre>
<p>This one is a bit trickier, calls back after 5, 4, 3, 2, 1 seconds 
and destroys itself:</p>
<pre>    my $repeat = 5;

    ngx_timer $repeat, $repeat, sub {
        $repeat--;
    };

</pre>

</div>
<h3 id="code_ngx_connector_ip_port_timeout_s"><code>ngx_connector $ip, $port, $timeout, sub { };</code></h3>
<div id="code_ngx_connector_ip_port_timeout_s-2">
<p>Creates connect handler and attempts to connect to <code>$ip:$port</code> within 
<code>$timeout</code> seconds. Calls back with connection in <code>@_</code> afterwards. 
On error calls back with <code>$!</code> set to some value.</p>
<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
<p>Additionally returns connection, if you need one. However, it might be a <code>0</code>
on some errors, make sure to check it's not if you are planning to use it
with flow control functions.</p>
<p>Example:</p>
<pre>    ngx_connector $ip, 80, 15, sub {

        return NGX_CLOSE
            if $!;

        my $c = shift;
        ...

        return NGX_READ;
    };

</pre>

</div>
<h3 id="code_ngx_reader_c_buf_min_max_timeou"><code>ngx_reader $c, $buf, $min, $max, $timeout, sub { };</code></h3>
<div id="code_ngx_reader_c_buf_min_max_timeou-2">
<p>Creates read handler for connection <code>$c</code> with buffer <code>$buf</code>.
<code>$min</code> indicates how much data should be present in <code>$buf</code> 
before the callback and <code>$max</code> limits total length of <code>$buf</code>.</p>
<p>Internally <code>$buf</code>, <code>$min</code>, <code>$max</code> and <code>$timeout</code> are stored
as refernces, so you can change them at any time to influence
reader's behavior.</p>
<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
<p>On error calls back with <code>$!</code> set to some value, including 
NGX_EOF in case of EOF. </p>
<pre>    my $buf;

    ngx_reader $c, $buf, $min, $max, $timeout, sub {

        return NGX_CLOSE
            if $! &amp;&amp; $! != NGX_EOF;
        ...

        return NGX_WRITE;
    };

</pre>
<p>Be aware, that <code>$min</code> and <code>$max</code> doesn't apply to the amount of data
you want to read but rather to the appropriate buffer size to call back with.</p>

</div>
<h3 id="code_ngx_writer_c_buf_timeout_sub_co"><code>ngx_writer $c, $buf, $timeout, sub { };</code></h3>
<div id="code_ngx_writer_c_buf_timeout_sub_co-2">
<p>Creates write handler for connection <code>$c</code> with buffer <code>$buf</code> and 
write timeout in &lt;$timeout&gt;.</p>
<p>Internally <code>$buf</code> and <code>$timeout</code> are stored as references, so 
changing them will influence writer's behavior. </p>
<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
<p>On error calls back with <code>$!</code> set to some value. NGX_EOF should be
treated as fatal error here. </p>
<p>Example:</p>
<pre>    my $buf = &quot;GET /\n&quot;;

    ngx_writer $c, $buf, 15, sub {

        return NGX_CLOSE
            if $!;
        ...

        return NGX_READ;
    };

</pre>

</div>
<h3 id="code_ngx_ssl_handshaker_c_timeout_su"><code>ngx_ssl_handshaker $c, $timeout, sub { };</code></h3>
<div id="code_ngx_ssl_handshaker_c_timeout_su-2">
<p>Creates its own internal handler for both reading and writing and tries 
to do SSL handshake. </p>
<p>Expects one of the following control flow constants as a result of callback: </p>
<pre>    NGX_CLOSE
    NGX_READ 
    NGX_WRITE
    NGX_SSL_HANDSHAKE

</pre>
<p>On error calls back with <code>$!</code> set to some value. </p>
<p>It's important to understand that handshaker will replace your previous 
reader and writer, so you have to create new ones.</p>
<p>Typically it should be called inside connector's callback:</p>
<pre>    ngx_connector ... sub {

        return NGX_CLOSE 
            if $!;

        my $c = shift;

        ngx_ssl_handshaker $c, 15, sub {

            return NGX_CLOSE
                if $!;
            ...

            ngx_writer ... sub { };

            ngx_reader ... sub { };

            return NGX_WRITE;
        };

        return NGX_SSL_HANDSHAKE;
    };

</pre>

</div>
<h3 id="code_ngx_resolver_name_timeout_sub_c"><code>ngx_resolver $name, $timeout, sub { };</code></h3>
<div id="code_ngx_resolver_name_timeout_sub_c-2">
<p>Creates resolver's handler and tries to resolve <code>$name</code> in <code>$timeout</code>
seconds using resolver specified in <cite>nginx-perl.conf</cite>.</p>
<p>On success returns all resolved IP addresses into <code>@_</code>.</p>
<p>On error calls back with <code>$!</code> set to some value, $_[0] set to one of the
resolver-specific error constants and with textual explanation in $_[1]:</p>
<pre>    NGX_RESOLVE_FORMERR
    NGX_RESOLVE_SERVFAIL
    NGX_RESOLVE_NXDOMAIN
    NGX_RESOLVE_NOTIMP
    NGX_RESOLVE_REFUSED
    NGX_RESOLVE_TIMEDOUT

</pre>
<p>This is a thin wrapper around nginx's internal resolver.
All its current problems apply. To use it in production you'll need
a local resolver, like named that does actual resolving.</p>
<pre>    ngx_resolver $host, $timeout, sub {

        if ($!) {
            my $errcode = $_[0];
            my $errstr  = $_[1];

            warn &quot;failed to resolve $host: $errstr\n&quot;;
            ...

            return;
        }

        my @IPs = @_; # list of all resolved IP addresses
        ...
    };

</pre>

</div>
<h1 id="CONNECTION_TAKEOVER">CONNECTION TAKEOVER</h1>
<div id="CONNECTION_TAKEOVER_CONTENT">
<p>It is possible to takeover client connection completely and create
you own reader and writer on that connection. 
You need this for websockets and protocol upgrade in general.</p>

</div>
<h2 id="METHODS-2">METHODS</h2>
<div id="METHODS_CONTENT-2">
<p>There are two methods to support this:</p>

</div>
<h3 id="code_r_gt_take_connection_code"><code>$r-&gt;take_connection</code></h3>
<div id="code_r_gt_take_connection_code_CONTE">
<p><code>$r-&gt;take_connection</code> initializes internal data structure and 
replaces connection's data with it. Returns connection on success
or <code>undef</code> on error.</p>
<pre>    my $c = $r-&gt;take_connection;

</pre>

</div>
<h3 id="code_r_gt_give_connection_code"><code>$r-&gt;give_connection</code></h3>
<div id="code_r_gt_give_connection_code_CONTE">
<p><code>$r-&gt;give_connection</code> attaches request <code>$r</code> back to its connection.
Doesn't return anything.</p>

</div>
<h2 id="TAKEOVER">TAKEOVER</h2>
<div id="TAKEOVER_CONTENT">
<p>So, to takeover you need to take connection from the request, 
tell nginx that you are going to finalize it later by calling 
<code>$r-&gt;main_count_inc</code>, create reader and/or writer on that
connection, start reading and/or writing flow and return NGX_DONE
from your HTTP handler:</p>
<pre>    sub handler {
        my $r = shift;

        my $c = $r-&gt;take_connection()
            or return HTTP_SERVER_ERROR;

        $r-&gt;main_count_inc;

            my $buf;

            ngx_reader $c, $buf, ... , sub {

                if ($!) {
                    $r-&gt;give_connection;
                    $r-&gt;finalize_request(NGX_DONE);

                    return NGX_NOOP;
                }

                ...
            };

            ngx_writer $c, ... , sub {

                if ($!) {
                    $r-&gt;give_connection;
                    $r-&gt;finalize_request(NGX_DONE);

                    return NGX_NOOP;
                }

                ...
            };

            ngx_read($c);

        return NGX_DONE;
    }

</pre>
<p>Once you are done with the connection or connection failed with some error
you MUST give connection back to the request and finalize it:</p>
<pre>    $r-&gt;give_connection;
    $r-&gt;finalize_request(NGX_DONE);

    return NGX_NOOP;

</pre>
<p>Usually you will also need to return NGX_NOOP instead of NGX_CLOSE,
since your connection is going to be closed within http request's
finalizer. But it shouldn't cuase any problems either way.</p>

</div>
<h1 id="TIPS_AND_TRICKS">TIPS AND TRICKS</h1>
<div id="TIPS_AND_TRICKS_CONTENT">

</div>
<h2 id="SELF_SUFFICIENT_HANDLERS">SELF-SUFFICIENT HANDLERS</h2>
<div id="SELF_SUFFICIENT_HANDLERS_CONTENT">
<p>It's important to know how and actually fairly easy to create 
self-sufficient reusable handlers for <strong>nginx-perl</strong>.</p>
<p>Just remember couple of things: </p>
<p>1. Use <code>$r-&gt;location_name</code> as a prefix:</p>
<pre>    location /foo/ {
        perl_handler My::handler;
    }

    sub handler {
        ...

        my $prefix =  $r-&gt;location_name;
           $prefix =~ s/\/$//;

        $out = &quot;&lt;a href=$prefix/something &gt; do something &lt;/a&gt;&quot;;
        # will result in &quot;&lt;a href=/foo/something &gt; do something &lt;/a&gt;&quot;
        ...
    }

</pre>
<p>2. Use <code>$r-&gt;variable</code> to configure handlers and to access per-server 
and per-location variables:</p>
<pre>    location /foo/ {
        set $conf_bar &quot;baz&quot;;
        perl_handler My::handler;
    }

    sub handler {
        ...

        my $conf_bar      = $r-&gt;variable('conf_bar');
        my $document_root = $r-&gt;variable('document_root');
        ...
    }

</pre>
<p>3. Use <code>$r-&gt;ctx</code> to exchange arbitrary data between handlers:</p>
<pre>    sub handler {
        ...

        my $ctx = { foo =&gt; 'bar' };
        $r-&gt;ctx($ctx);

        my $ctx = $r-&gt;ctx;
        ...
    }

</pre>
<p>4. Use <code>perl_eval</code> to configure your modules directly 
from <cite>nginx-perl.conf</cite>:</p>
<pre>    http {

        perl_require  MyModule.pm;

        perl_eval  ' $My::CONF{foo} = &quot;bar&quot; ';
    }




    package My;

    our %CONF = ();

    sub handler {
        ...

        warn $CONF{foo};
        ...
    }

</pre>
<p>Check out <cite>eg/self-sufficient</cite> to see all this in action:</p>
<pre>    % ./objs/nginx-perl -p eg/self-sufficient

</pre>

</div>
<h1 id="SEE_ALSO">SEE ALSO</h1>
<div id="SEE_ALSO_CONTENT">
<p><a href="Nginx/Test.html">Nginx::Test</a>, <a href="Nginx/Util.html">Nginx::Util</a>, <a href="Nginx/Redis.html">Nginx::Redis</a>,
<a href="http://zzzcpan.github.com/nginx-perl">http://zzzcpan.github.com/nginx-perl</a>,
<a href="http://wiki.nginx.org/EmbeddedPerlModule">http://wiki.nginx.org/EmbeddedPerlModule</a>,
<a href="http://nginx.net/">http://nginx.net/</a> </p>

</div>
<h1 id="AUTHOR">AUTHOR</h1>
<div id="AUTHOR_CONTENT">
<p>Igor Sysoev,
Alexandr Gomoliako &lt;zzz@zzz.org.ua&gt;</p>

</div>
<h1 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h1>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright (C) Igor Sysoev</p>
<p>Copyright 2011 Alexandr Gomoliako. All rights reserved.</p>
<p>This module is free software. It may be used, redistributed and/or modified 
under the same terms as <strong>nginx</strong> itself.</p>

</div>
</div>
	</div>

	<div class="w100 centr cl blockpadtop pagepadbottom">
		<p>&copy; 2012 Alexandr Gomoliako</p>
	</div>
</div>


</body>
</html>
